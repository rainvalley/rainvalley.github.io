<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://raincorn.top</id>
    <title>Chores</title>
    <updated>2022-01-23T17:14:39.465Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://raincorn.top"/>
    <link rel="self" href="https://raincorn.top/atom.xml"/>
    <subtitle>傅立叶是一首数学的诗，黑格尔是一首辩证法的诗。</subtitle>
    <logo>https://raincorn.top/images/avatar.png</logo>
    <icon>https://raincorn.top/favicon.ico</icon>
    <rights>All rights reserved 2022, Chores</rights>
    <entry>
        <title type="html"><![CDATA[iCE40UP5K实现Σ-Δ ADC采集及电压表]]></title>
        <id>https://raincorn.top/ice40up5k_sigma_delta_adc/</id>
        <link href="https://raincorn.top/ice40up5k_sigma_delta_adc/">
        </link>
        <updated>2022-01-23T13:54:37.000Z</updated>
        <content type="html"><![CDATA[<p>在本文中，我们将使用硬禾学堂的“基于iCE40UP5K的FPGA学习平台”开发板来实现一个Σ-Δ ADC采集，并制作一个简易的电压表。在了解相关内容与原理时，发现了许多学习过的知识，通信/电信人狂喜。</p>
<h1 id="目标">目标</h1>
<p>基于Lattice iCE40UP5K实现一个Σ-Δ ADC采集，采集后的电压将会在OLED屏幕上显示，实现一个简易的电压表，效果如下图所示：</p>
<figure data-type="image" tabindex="1"><img src="https://imgs.raincorn.top/imgs/202201232206857.jpg" alt="简易电压表效果图" loading="lazy"></figure>
<h1 id="σ-δ-adc采集">Σ-Δ ADC采集</h1>
<p>在大多数FPGA芯片上均无ADC外设，当需要低成本/多通道采集模拟量时，可以考虑此方案。同样地，此学习平台上也没有使用集成ADC与DAC模块，其ADC采集使用了PWM+电压比较器实现Σ-Δ ADC，其DAC输出使用了R-2R权电阻网络来实现。本节将详述ADC实现原理，仿真，参数的选择，代码实现。</p>
<h2 id="adc参数">ADC参数</h2>
<p>在讨论一块ADC性能的时候，往往关注两个指标：<strong>采样率、量化位数</strong>。比如我们常用的黑金AN108模块上，采用了AD9280作为其ADC，查阅ADI官网其介绍如下：</p>
<blockquote>
<p>AD9280是一款单芯片、8位、32 MSPS模数转换器（ADC），采用单电源供电，内置一个片内采样保持放大器和基准电压源。它采用多级差分流水线架构，数据速率达32 MSPS，在整个工作温度范围内保证无失码。</p>
</blockquote>
<p>采样率与量化位数作为两个重要的指标被显著标注，我们可以得知该芯片的采样率为32MSPS（Million Samples Per Second）、量化位数8 bit。后文我们将会通过理论分析来确定这两个参数。</p>
<h2 id="adc实现原理">ADC实现原理</h2>
<p>在该学习平台上，其PWM+电压比较器实现Σ-Δ ADC的原理图如下：</p>
<figure data-type="image" tabindex="2"><img src="https://imgs.raincorn.top/imgs/202201232218318.png" alt="Σ-Δ ADC原理图" loading="lazy"></figure>
<p>可以看到，在该电路图中包含一个比较器，其同相输入端接模拟输入，反向输入端接PWM输入，比较后输出结果。在反相输入端PWM_V2连接着一个电阻和一个电容，其构成一个简易的<strong>一阶RC滤波器</strong>。该一阶RC滤波器截至频率为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>c</mi></msub><mo>=</mo><mfrac><mn>1</mn><mrow><mn>2</mn><mi>π</mi><mi>R</mi><mi>C</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">f_{c}=\frac{1}{2\pi RC}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">π</span><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，工程上将幅度值下降到原来的0.707倍（-3dB）称作截止频率点，电路的带宽也由-3dB点定义。通过对输入的PWM波形进行滤波可以得到一个近似的直流值，与Ain2进行比较输出，通过不断调节占空比（假设由低到高），当输出C_OUT2由高变低时便可使用占空比来表示模拟输入量。</p>
<p>滤波的目的是得到直流量，一个PWM波进行傅里叶变换后可观察到其存在许多高次谐波，一阶RC的目的便是将基频与谐波滤除。</p>
<p>我们知道，一个典型的PWM波形脉冲区间包括高电平区间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mi>H</mi></msub></mrow><annotation encoding="application/x-tex">t_H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.08125em;">H</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>与低电平区间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mi>L</mi></msub></mrow><annotation encoding="application/x-tex">t_L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，其占空比常定义为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>u</mi><mi>t</mi><mi>y</mi><mo>=</mo><mfrac><msub><mi>t</mi><mi>H</mi></msub><mrow><msub><mi>t</mi><mi>H</mi></msub><mo>+</mo><msub><mi>t</mi><mi>L</mi></msub></mrow></mfrac></mrow><annotation encoding="application/x-tex">duty=\frac{t_H}{t_H+t_L}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2861659999999997em;vertical-align:-0.44530499999999995em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8408609999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3567071428571427em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.08125em;">H</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.14329285714285717em;"><span></span></span></span></span></span></span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3567071428571427em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.14329285714285717em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.410305em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3567071428571427em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.08125em;">H</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.14329285714285717em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.44530499999999995em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>。接触过单片机的读者可能会联想起PWM控制电机转速，LED亮度的实验，当调节占空比时可以改变上述参量，本电路中经过RC低通滤波器便可得到一个近似的直流电压值。</p>
<figure data-type="image" tabindex="3"><img src="https://imgs.raincorn.top/imgs/202201232323464.png" alt="PWM波形示意图" loading="lazy"></figure>
<p>当对不同占空比的PWM波形（频率均为200K）做傅里叶变换进行频谱分析时，可以得到如下频谱图。可以观察到，当改变不同占空比时，PWM波的主要频率分量仍集中在200K，400K附近，改变的主要是直流分量。</p>
<figure data-type="image" tabindex="4"><img src="https://imgs.raincorn.top/imgs/202201232345188.png" alt="不同占空比下PWM波形频谱图" loading="lazy"></figure>
<p>当给此PWM信号加以截至频率100KHz，阻带衰减60dB的理想低通滤波器后可以得到如下波形图。可以观察到随着时间的推移信号逐渐趋近于直流，也可以理解为200K与400K的分量被滤除得到直流分量。</p>
<figure data-type="image" tabindex="5"><img src="https://imgs.raincorn.top/imgs/202201240001871.png" alt="200K PWM经过100K低通滤波器" loading="lazy"></figure>
<p>仿真所用的MATLAB代码如下：</p>
<pre><code class="language-c">close all;clear;clc;

fs = 1e6; %sample rate is 1M
t = 0:1/fs:1e-1-1/fs; %generate the data between 0-1ms to rise the fft resulation
n = length(t);
n_index = 0:n-1;
f_index = n_index*fs/n;

% 25%
x = square(2*pi*200e3*t,25) + 1; %generate the PWM with special duty
subplot(321);stem(t,x);axis([0 2e-5 0 2]);title(&quot;Time: 25% Duty&quot;);
mag_x= 20*log10(abs(fft(x)));
subplot(322);plot(f_index(1:n/2),mag_x(1:n/2));title(&quot;Spec(dB): 25% Duty&quot;);

% 50%
x = square(2*pi*200e3*t,50) + 1; %generate the PWM with special duty
subplot(323);stem(t,x);axis([0 2e-5 0 2]);title(&quot;Time: 50% Duty&quot;);
mag_x= 20*log10(abs(fft(x)));
subplot(324);plot(f_index(1:n/2),mag_x(1:n/2));title(&quot;Spec(dB): 50% Duty&quot;);

% 75%
x = square(2*pi*200e3*t,75) + 1; %generate the PWM with special duty
subplot(325);stem(t,x);axis([0 2e-5 0 2]);title(&quot;Time: 75% Duty&quot;);
mag_x= 20*log10(abs(fft(x)));
subplot(326);plot(f_index(1:n/2),mag_x(1:n/2));title(&quot;Spec(dB): 75% Duty&quot;);
</code></pre>
<h2 id="adc参数选取">ADC参数选取</h2>
<p>前文所述，ADC有两个重要的指标：采样率、量化位数。本节将介绍如何选取这两个颇为重要的参数，很多时候参数的选择涉及多方面的权衡。本涉及采用了如下参数：</p>
<blockquote>
<p>量化位数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>=</mo><mn>8</mn><mi>b</mi><mi>i</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">N=8 bit</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">8</span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span></span></span></span></p>
<p>采样率<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>s</mi></msub><mo>=</mo><mn>200</mn><mi>K</mi><mi>H</mi><mi>z</mi></mrow><annotation encoding="application/x-tex">f_s=200KHz</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span></span></span></span></p>
<p>PWM产生模块时钟<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>c</mi><mi>l</mi><mi>k</mi></mrow></msub><mo>=</mo><mn>51.2</mn><mi>M</mi></mrow><annotation encoding="application/x-tex">f_{clk}=51.2M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">1</span><span class="mord">.</span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span></p>
<p>RC滤波器元件<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mo>=</mo><mn>1000</mn><mi mathvariant="normal">Ω</mi><mo separator="true">,</mo><mi>C</mi><mo>=</mo><mn>1000</mn><mi>p</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">R=1000\Omega,C=1000pF</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">Ω</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span></span></span></span></p>
<p>RC滤波器截至频率<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>c</mi></msub><mo>=</mo><mn>160</mn><mi>K</mi><mi>H</mi><mi>z</mi></mrow><annotation encoding="application/x-tex">f_c=160KHz</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mord">0</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span></span></span></span></p>
</blockquote>
<p>在参数的选择过程中，可以参考如下步骤进行综合考量：</p>
<ul>
<li>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">f_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的选择是否满足要求？当需要采样一个非直流信号时，需要满足奈奎斯特采样定理，即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>s</mi></msub><mo>≥</mo><mn>2</mn><msub><mi>f</mi><mi>H</mi></msub></mrow><annotation encoding="application/x-tex">f_s\ge2f_H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.08125em;">H</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>的选择是否满足要求？一个ADC的分辨率很大程度上取决于量化位数，分辨率受供电电压与位数二者共同决定，即有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>r</mi><mi>e</mi><mi>s</mi></mrow></msub><mo>=</mo><mfrac><msub><mi>V</mi><mrow><mi>D</mi><mi>D</mi></mrow></msub><msup><mn>2</mn><mi>n</mi></msup></mfrac></mrow><annotation encoding="application/x-tex">f_{res}=\frac{V_{DD}}{2^n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2336359999999997em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8886359999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.5935428571428571em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.410305em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3567071428571427em;margin-left:-0.22222em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.14329285714285717em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>。同时，其信噪比满足<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>N</mi><mi>R</mi><mo>=</mo><mn>6</mn><mi>N</mi></mrow><annotation encoding="application/x-tex">SNR=6N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>，即每提高一位可以提高<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>6</mn><mi>d</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">6dB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>的信噪比。例如在一个3.3V供电的系统中，8位量化最高可以做到0.012890625V的分辨率。</p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>s</mi></msub><mo>&gt;</mo><msub><mi>f</mi><mi>c</mi></msub></mrow><annotation encoding="application/x-tex">f_s &gt; f_c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是否满足？很多情况下要求采样率应尽可能大于截止频率，这样信号的直流分量便可以较好地滤除出来。</p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>c</mi><mi>l</mi><mi>k</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{clk}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是否能满足FPGA布局布线的要求？<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>c</mi><mi>l</mi><mi>k</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{clk}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的大小满足如下条件：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>c</mi><mi>l</mi><mi>k</mi></mrow></msub><mo>=</mo><mfrac><msup><mn>2</mn><mi>N</mi></msup><mi>T</mi></mfrac><mo>=</mo><msup><mn>2</mn><mi>N</mi></msup><mo>∗</mo><msub><mi>f</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">f_{clk}=\frac{2^N}{T}={2^N}*{f_s}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.3823649999999998em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0373649999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9190928571428572em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>，可以观察到模块时钟的频率随着量化位数的增加呈指数倍增加，因此Σ-Δ ADC常用于低频下高精度的检测。当时钟频率提高时会给FPGA的布线带来困难，考虑到iCE40的定位属于低功耗FPGA，故此处选择51.2M作为时钟频率（当然我建议您可以尝试提高频率以获得更稳定的采样效果）。</p>
<figure data-type="image" tabindex="6"><img src="https://imgs.raincorn.top/imgs/202201240048989.png" alt="51.2M时钟生成模块" loading="lazy"></figure>
</li>
</ul>
<h3 id="rc较大">RC较大</h3>
<p>在ADC实现原理一节中我们详细分析了滤波器存在的必要，可以观察到当RC越大时滤波器的截止频率也就越高，更有利于PWM信号直流分量的提取。但同时存在一个时间常数的概念，时间常数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>τ</mi><mo>≈</mo><mn>0.69</mn><mi>R</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">\tau \approx  0.69RC</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.48312em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">6</span><span class="mord">9</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span> ，当不受限制地提高RC将会提高时间常数进而减缓电路的响应时间。故我们可以总结如下特性：</p>
<blockquote>
<p>优点：便于直流分量的提取，减小滤波后直流信号出现波动。</p>
<p>缺点：提高时间常数，电路的响应速度降低。</p>
</blockquote>
<h3 id="rc较小">RC较小</h3>
<p>RC较小时的特性与之相反，总结如下：</p>
<blockquote>
<p>优点：时间常数小，电路响应速度快。</p>
<p>缺点：由于截至频率提高，因此需要更大的采样率才能达到较好的效果。</p>
</blockquote>
<h3 id="如何克服">如何克服？</h3>
<p>加入电感，提高滤波阶次，加入有源滤波，提高采样率。</p>
<h2 id="verilog代码实现">Verilog代码实现</h2>
<p>该模块包含三个输入与两个输出，具体介绍如下：</p>
<ul>
<li><code>sys_clk</code>与<code>sys_rst_n</code>分别为模块的时钟输入与复位输入</li>
<li><code>pwm_adc_in</code>连接到比较器的输出，用于获取比较信息</li>
<li><code>pwm_val</code>为该模块输出的ADC数值，范围0-255</li>
<li><code>pwm_adc_out</code>连接到比较器的反相输入端，通过改变占空比以获得不同的直流电压</li>
</ul>
<p>检测的原理为<code>pwm_adc_out</code>不断提高占空比，当<code>pwm_adc_in</code>由高到低产生下降沿变化时，输出此时的占空比数值，此时的数值即为ADC采样的数值。</p>
<pre><code class="language-c">module pwm_adc(
	input sys_clk,
	input sys_rst_n,
	input pwm_adc_in,
	output reg [7:0] pwm_val,
	output pwm_adc_out
);

reg r_adc_in;//Thought the D-reg to get the buffer I/O level.
always@(posedge sys_clk or negedge sys_rst_n)begin
	if(!sys_rst_n)begin
		r_adc_in &lt;= 1'b0;
	end else begin
		r_adc_in &lt;= pwm_adc_in;
	end
end

wire adc_in_fall;//When the pwm_adc_in is falling,the adc_in_fall will output high.
assign adc_in_fall = (r_adc_in | pwm_adc_in)&amp;(pwm_adc_in == 1'b0);

//-----The pwm generation-----
reg [7:0] pwm_adder;
reg pwm_adder_overflow; //Complete a counter and generate the overflow(one clock period)
always@(posedge sys_clk or negedge sys_rst_n)begin
	if(!sys_rst_n)begin
		pwm_adder &lt;= 8'd0;
		pwm_adder_overflow &lt;= 1'b0;
	end else if(pwm_adder == 8'hff) begin
		pwm_adder &lt;= pwm_adder + 1'b1;
		pwm_adder_overflow &lt;= 1'b1;
	end else begin
		pwm_adder &lt;= pwm_adder + 1'b1;
		pwm_adder_overflow &lt;= 1'b0;
	end
end

reg [7:0] pwm_set;
always@(posedge sys_clk or negedge sys_rst_n)begin
	if(!sys_rst_n)begin
		pwm_set &lt;= 8'd0;
	end else if(adc_in_fall == 1'b1)begin
		pwm_val &lt;= pwm_set;
		pwm_set &lt;= 8'd0;
	end else if(pwm_adder_overflow == 1'b1 &amp;&amp; pwm_adc_in == 1'b0)begin
		pwm_set &lt;= pwm_set;
	end else if(pwm_adder_overflow == 1'b1 &amp;&amp; pwm_adc_in == 1'b1)begin
		pwm_set &lt;= pwm_set + 1'b1;
	end
end

assign pwm_adc_out = (pwm_adder &lt;= pwm_set) ? 1'b1 : 1'b0;

endmodule
</code></pre>
<h1 id="bcd码生成">BCD码生成</h1>
<p>由于ADC模块产生的数值为十进制，如需将其显示出来则需要一个BCD码型转换模块提取个、十、百、千位。不同于单片机内部使用乘除法获取各位的操作，在FPGA内部乘除法十分消耗资源，因此往往采用移位判断法，具体代码参考野火。</p>
<pre><code class="language-c">module  bcd_8421
(
    input   wire            sys_clk     ,   //系统时钟，频率50MHz
    input   wire            sys_rst_n   ,   //复位信号，低电平有效
    input   wire    [19:0]  data        ,   //输入需要转换的数据

    output  reg     [3:0]   unit        ,   //个位BCD码
    output  reg     [3:0]   ten         ,   //十位BCD码
    output  reg     [3:0]   hun         ,   //百位BCD码
    output  reg     [3:0]   tho         ,   //千位BCD码
    output  reg     [3:0]   t_tho       ,   //万位BCD码
    output  reg     [3:0]   h_hun           //十万位BCD码
);

//********************************************************************//
//******************** Parameter And Internal Signal *****************//
//********************************************************************//

//reg   define
reg     [4:0]   cnt_shift   ;   //移位判断计数器
reg     [43:0]  data_shift  ;   //移位判断数据寄存器
reg             shift_flag  ;   //移位判断标志信号

//********************************************************************//
//***************************** Main Code ****************************//
//********************************************************************//

//cnt_shift:从0到21循环计数
always@(posedge sys_clk or negedge sys_rst_n)
    if(sys_rst_n == 1'b0)
        cnt_shift   &lt;=  5'd0;
    else    if((cnt_shift == 5'd21) &amp;&amp; (shift_flag == 1'b1))
        cnt_shift   &lt;=  5'd0;
    else    if(shift_flag == 1'b1)
        cnt_shift   &lt;=  cnt_shift + 1'b1;
    else
        cnt_shift   &lt;=  cnt_shift;
       
//data_shift：计数器为0时赋初值，计数器为1~20时进行移位判断操作
always@(posedge sys_clk or negedge sys_rst_n)
    if(sys_rst_n == 1'b0)
        data_shift  &lt;=  44'b0;
    else    if(cnt_shift == 5'd0)
        data_shift  &lt;=  {24'b0,data};
    else    if((cnt_shift &lt;= 20) &amp;&amp; (shift_flag == 1'b0))
        begin
            data_shift[23:20]   &lt;=  (data_shift[23:20] &gt; 4) ? (data_shift[23:20] + 2'd3) : (data_shift[23:20]);
            data_shift[27:24]   &lt;=  (data_shift[27:24] &gt; 4) ? (data_shift[27:24] + 2'd3) : (data_shift[27:24]);
            data_shift[31:28]   &lt;=  (data_shift[31:28] &gt; 4) ? (data_shift[31:28] + 2'd3) : (data_shift[31:28]);
            data_shift[35:32]   &lt;=  (data_shift[35:32] &gt; 4) ? (data_shift[35:32] + 2'd3) : (data_shift[35:32]);
            data_shift[39:36]   &lt;=  (data_shift[39:36] &gt; 4) ? (data_shift[39:36] + 2'd3) : (data_shift[39:36]);
            data_shift[43:40]   &lt;=  (data_shift[43:40] &gt; 4) ? (data_shift[43:40] + 2'd3) : (data_shift[43:40]);
        end
    else    if((cnt_shift &lt;= 20) &amp;&amp; (shift_flag == 1'b1))
        data_shift  &lt;=  data_shift &lt;&lt; 1;
    else
        data_shift  &lt;=  data_shift;

//shift_flag：移位判断标志信号，用于控制移位判断的先后顺序
always@(posedge sys_clk or negedge sys_rst_n)
    if(sys_rst_n == 1'b0)
        shift_flag  &lt;=  1'b0;
    else
        shift_flag  &lt;=  ~shift_flag;

//当计数器等于20时，移位判断操作完成，对各个位数的BCD码进行赋值
always@(posedge sys_clk or negedge sys_rst_n)
    if(sys_rst_n == 1'b0)
        begin
            unit    &lt;=  4'b0;
            ten     &lt;=  4'b0;
            hun     &lt;=  4'b0;
            tho     &lt;=  4'b0;
            t_tho   &lt;=  4'b0;
            h_hun   &lt;=  4'b0;
        end
    else    if(cnt_shift == 5'd21)
        begin
            unit    &lt;=  data_shift[23:20];
            ten     &lt;=  data_shift[27:24];
            hun     &lt;=  data_shift[31:28];
            tho     &lt;=  data_shift[35:32];
            t_tho   &lt;=  data_shift[39:36];
            h_hun   &lt;=  data_shift[43:40];
        end

endmodule
</code></pre>
<p>BCD模块在OLED模块内部例化，其例化代码如下。注意此处对ADC采样进来的数值进行了近似操作以减少乘法器的使用，由于在3.3V下8位量化的分辨率为0.012890625，故将其扩大10000倍取128恰对应着左移8位的操作。显示数据的拼接在<code>dis_dat_buff</code>内进行。</p>
<pre><code class="language-c">	wire [15:0]				dis_dat_mult = dis_dat &lt;&lt; 7; //The voltage multed by 128(3.3/256 = 0.01289) to get a similar number
	wire [(6*8-1):0]		dis_dat_buff; //The buffer of dis_dat
	wire [3:0]				dis_ten;
	wire [3:0]				dis_hun;
	wire [3:0]				dis_tho;
	wire [3:0]				dis_t_tho;
	assign dis_dat_buff = {4'd0,dis_t_tho,&quot;.&quot;,4'd0,dis_tho,4'd0,dis_hun,4'd0,dis_ten,&quot;V&quot;};
	bcd_8421 u_bcd_8421(
	.sys_clk(clk), //系统时钟，频率50MHz
	.sys_rst_n(rst_n), //复位信号，低电平有效
    .data(dis_dat_mult), //输入需要转换的数据

    .unit(), //个位BCD码
    .ten(dis_ten), //十位BCD码
    .hun(dis_hun), //百位BCD码
    .tho(dis_tho), //千位BCD码
    .t_tho(dis_t_tho), //万位BCD码
    .h_hun() //十万位BCD码
	);
</code></pre>
<h1 id="顶层例化">顶层例化</h1>
<p>受限于iCE40UP5K布线资源的问题，当系统锁相环时钟由外部输入时，外部时钟便不可再用于其它模块的时钟。因此此处使用了该FPGA芯片的内部时钟，通过<code>HSOSC</code>原语进行例化，注意Radiant中的原语与其它IDE不相同。</p>
<pre><code class="language-c">module voltmeter(
//	input in_clk, //Use the internal clock source to avoid restrict
	input in_rst_n,
	input pwm_adc_in,
//	input debug, //The debug wire is connected to switch
//	output oled_csn, //The cs pin is disconnected
	output oled_rst,
	output oled_dcn,
	output oled_clk,
	output oled_dat,
	output pwm_adc_out
);

wire sys_clk;
HSOSC 
#( 
  .CLKHF_DIV (&quot;0b10&quot;) 
) u_HSOSC ( 
  .CLKHFEN (1'b1), 
  .CLKHFPU (1'b1), 
  .CLKHF   (sys_clk) 
);

wire sys_rst_n,clk_gen_locked,clk_pwm_adc;
assign sys_rst_n = in_rst_n &amp; clk_gen_locked;
clk_gen u_clk_gen(
	.ref_clk_i(sys_clk),
	.rst_n_i(in_rst_n),
	.lock_o(clk_gen_locked),
	.outcore_o(),
	.outglobal_o(clk_pwm_adc) //The pll out is connected with the global clock network
);

wire [7:0] pwm_val;
pwm_adc u_pwm_adc(
	.sys_clk(clk_pwm_adc),
	.sys_rst_n(sys_rst_n),
	
	.pwm_adc_in(pwm_adc_in),
	
	.pwm_val(pwm_val),
	.pwm_adc_out(pwm_adc_out)
);

oled12864 u_oled12864(
	.clk(sys_clk),		//The system clock
	.rst_n(sys_rst_n),		//The system reset
	
	.dis_dat(pwm_val),
//	.debug(debug),
	
	.oled_csn(),	//OLED ENABLE
	.oled_rst(oled_rst),	//OLED RESET
	.oled_dcn(oled_dcn),	//OLED DATA/COMMAND CONTROL
	.oled_clk(oled_clk),	//OLED CLOCK
	.oled_dat(oled_dat)	//OLED DATA
);
</code></pre>
<h1 id="其它">其它</h1>
<p>之前一直使用Xilinx、Altera的FPGA进行开发，相比于Lattice而言，其开发工具更显繁琐。Lattice的开发工具使用十分清爽且快，其综合布线一个OLED显示的工程只需要30s，在Vivado上都不够软件的加载时间。</p>
<p>当然，Lattice的开发流程缺点也蛮显著。譬如：时钟网络的布线资源受限；Lattice LSE的综合工具并不好用，从其带有一个Synplify Pro的选项便可看出，很多时候LSE综合不出来，更换Synplify便可解决。当然，以上这些缺点在学习时综合布线飞快面前显得就不那么重要。</p>
<h1 id="参考资料">参考资料</h1>
<p>1、硬禾学堂. 基于iCE40UP5K的FPGA学习平台[EB/OL]. [2022-1-23]. https://www.eetree.cn/project/detail/131.</p>
<p>2、电子森林. PWM的应用及相应的Verilog代码[EB/OL]. [2022-1-23]. https://www.eetree.cn/wiki/pwm_verilog.</p>
<p>3、吴大正. 《信号与线性系统分析》[M]. 第四版. 高等教育出版社, 2005-8.</p>
<p>4、童诗白、华成英. 《模拟电子技术基础(第五版)》[M]. 第五版. 高等教育出版社, 2015-1.</p>
<p>5、邱关源. 《电路》[M]. 第五版. 高等教育出版社, 2006-5.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[AM调制解调的MATLAB与FPGA实现]]></title>
        <id>https://raincorn.top/AM_Mod_and_Demod/</id>
        <link href="https://raincorn.top/AM_Mod_and_Demod/">
        </link>
        <updated>2022-01-20T15:03:43.000Z</updated>
        <content type="html"><![CDATA[<h1 id="新手福利-am信号调制解调">新手福利 --- AM信号调制解调</h1>
<p>在模拟通信系统中，基带信号通过对载波波形幅度，相位，频率的调制以达到将信号在载波上传输信息的目的。根据基带信号的类型可分为：模拟调制 &amp; 数字调制。</p>
<h1 id="调制原理">调制原理</h1>
<p>本文所述AM（<em>Amplitude Modulation</em>）调制，即是模拟信号对载波幅度进行调制，通过与载波信号相乘来进行频谱搬移。其中第一个公式为时域表达式，第二个公式为频域表达式。<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mrow><mi>A</mi><mi>M</mi></mrow></msub><mo>=</mo><mo>(</mo><msub><mi>A</mi><mn>0</mn></msub><mo>+</mo><mi>m</mi><mo>(</mo><mi>t</mi><mo>)</mo><mo>)</mo><mo>∗</mo><mi>c</mi><mi>o</mi><mi>s</mi><mo>(</mo><msub><mi>w</mi><mi>c</mi></msub><mi>t</mi><mo>+</mo><msub><mi>ϕ</mi><mi>c</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">S_{AM}=(A_0+m(t))*cos(w_ct+\phi_c)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">A</span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">ϕ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mrow><mi>A</mi><mi>M</mi></mrow></msub><mo>(</mo><mi>ω</mi><mo>)</mo><mo>=</mo><mfrac><msub><mi>A</mi><mn>0</mn></msub><mn>2</mn></mfrac><mo>∗</mo><mo>[</mo><mi>M</mi><mo>(</mo><mi>ω</mi><mo>+</mo><msub><mi>ω</mi><mi>c</mi></msub><mo>)</mo><mo>+</mo><mi>M</mi><mo>(</mo><mi>ω</mi><mo>−</mo><msub><mi>ω</mi><mi>c</mi></msub><mo>)</mo><mo>]</mo></mrow><annotation encoding="application/x-tex">S_{AM}(\omega)=\frac{A_0}{2}*[M(\omega+\omega_c)+M(\omega-\omega_c)]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">A</span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.233431em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8884309999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4101em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">]</span></span></span></span></p>
<p>在上文的公式中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>(</mo><mi>t</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">m(t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mclose">)</span></span></span></span>为基带信号（一般为低频信号），<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">A_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为直流偏置，用来将基带信号叠加到正半轴，使得在调制后信号仍然保持着<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>(</mo><mi>t</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">m(t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mclose">)</span></span></span></span>的包络。其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>o</mi><mi>s</mi><mo>(</mo><msub><mi>w</mi><mi>c</mi></msub><mi>t</mi><mo>+</mo><msub><mi>ϕ</mi><mi>c</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">cos(w_ct+\phi_c)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">ϕ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>为载波信号，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>ω</mi><mi>c</mi></msub></mrow><annotation encoding="application/x-tex">\omega_c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为载波角频率。</p>
<p>在描述AM信号的调制深度时，常定义为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>m</mi><mo>(</mo><mi>t</mi><msub><mo>)</mo><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></mrow><msub><mi>A</mi><mn>0</mn></msub></mfrac></mrow><annotation encoding="application/x-tex">\frac{m(t)_{max}}{A_0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.4550999999999998em;vertical-align:-0.44509999999999994em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">t</span><span class="mclose mtight"><span class="mclose mtight">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.44509999999999994em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，当调制深度大于1时为过调幅现象，此时因为存在相位突变，调制后的信号包络无法反映原始信号<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>(</mo><mi>t</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">m(t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mclose">)</span></span></span></span>。</p>
<h1 id="matlab仿真">MATLAB仿真</h1>
<blockquote>
<p>在开始之前，先阐述一下各项参数：</p>
<ul>
<li>采样率：10M</li>
<li>基带信号频率：100K</li>
<li>载波信号频率：1M</li>
<li>采样点数：1000点（为了对齐一个周期的正弦波，避免FPGA仿真时出现相位的突变）</li>
</ul>
</blockquote>
<h2 id="调制">调制</h2>
<p>在MATLAB调制的仿真中，我们需要将基带信号输出到TXT文档，供FPGA仿真时读取，作为AD采样的数值。同时绘制调制后的频域波形与时域波形，便于直观对照。</p>
<pre><code class="language-c">close all;clear;clc;
fs=10e6;
f1=100e3;
f2=1e6;
n=1000;
t=0:1/fs:(n-1)/fs;
s1=sin(2*pi*f1*t); %基带信号
s=(s1+max(s1)).*sin(2*pi*f2*t); %调制后的信号
s_fft=fft(s);s_fft_abs=abs(s_fft);
subplot(311);plot(s1(1:500));title(&quot;基带信号时域波形&quot;);
subplot(312);plot(s(1:500));title(&quot;调制信号时域波形&quot;);
subplot(313);plot(s_fft_abs(1:length(s_fft)/2));title(&quot;调制信号频域波形&quot;);

Q=8; %此处是量化位数，为了与ADC对应此处设置为8位
s1=s1/max(abs(s1));
Q_s=round(s1*(2^(Q-1)-1));
Q_s=Q_s+(2^(Q-1)-1);
fid=fopen(&quot;am_mod.txt&quot;,&quot;w&quot;);
for i=1:length(Q_s)
    Q_data=dec2bin(Q_s(i),Q); %与ADC对应，输出为无符号二进制数，注意在新版MATLAB中此函数有变化
    fprintf(fid,&quot;%s\r\n&quot;,Q_data);
end
fprintf(fid,&quot;;&quot;);
fclose(fid);
</code></pre>
<p>其绘制的图片如下，可以观察到在调制后的频域上有三个尖峰，分别对应0.9，1.0，1.1三个频点：</p>
<figure data-type="image" tabindex="1"><img src="https://imgs.raincorn.top/imgs/202110081603451.png" alt="image-20211008090850756" loading="lazy"></figure>
<h2 id="解调">解调</h2>
<p><s>其实不用写代码的</s></p>
<p>在MATLAB信号分析其中拖入变量s，分析器中选择包络即可提取信号包络，然后再经过一个低通滤波器即可。提取上包络后的波形如下图：</p>
<figure data-type="image" tabindex="2"><img src="https://imgs.raincorn.top/imgs/202110081603802.png" alt="image-20211008150157310" loading="lazy"></figure>
<h1 id="fpga仿真">FPGA仿真</h1>
<p>本仿真在Vivado 2018.2上测试，元件选择为Xilinx XC7Z010CLG400，需要用到的IP核介绍如下。</p>
<h2 id="ip核">IP核</h2>
<h3 id="clocking-wizard">Clocking Wizard</h3>
<p>该IP核通过MMCM与PLL来输出特定频率到所需的模块，其中PLL可看作MMCM的子集。该IP核较为简单，介绍一个容易出问题的地方。</p>
<figure data-type="image" tabindex="3"><img src="https://imgs.raincorn.top/imgs/202110081603819.png" alt="image-20211008091817238" loading="lazy"></figure>
<p>如上图所示，在Input Clock Information的Source一栏中可以选择时钟来源，分别为：</p>
<ul>
<li>单端时钟：在后续的引脚选择上，必须与器件的专用时钟端口对应。</li>
<li>差分时钟：类似于HDMI中的CLK+，CLK-，通过差分来抵消传输过程中的干扰。</li>
<li>全局时钟：当该IP核的输入来自工程内的其他模块时，需要选择此。</li>
<li>不缓冲输入：当从普通IO口引入时钟时，由于已经添加了一个Buffer，故此处不必再添加Buffer。</li>
</ul>
<h3 id="dds-compiler">DDS Compiler</h3>
<p>该IP核可以用于输出特定频率的正余弦波以及相位变化，可以通过AXI4接口配置其初始相位以及相位增量（改变输出频率），相关介绍如下：</p>
<h4 id="configuration">Configuration</h4>
<ul>
<li>Configuration Options：配置为相位生成或正余弦波生成，或二者兼有。</li>
<li>System Requirements：配置输入频率，通道数与参数设置，这里一般选择为System Parameters，便于在后面直接配置输出频率。</li>
<li>System Parameters：可配置杂散范围与频率分辨率的数值，此配置将会决定相位宽度。</li>
</ul>
<h4 id="implementation">Implementation</h4>
<ul>
<li>Phase Increment Programmability：配置相位增量是否可调，可用来改变输出频率。</li>
<li>Phase Offset Programmability：配置相位偏移是否可调。</li>
<li>Output：配置输出波形（正，余弦或二者兼有），输出极性（是否反转，幅度范围），是否有相位输出（我经常不勾选）。</li>
</ul>
<h4 id="output-frequencies">Output Frequencies</h4>
<p>此处可用于配置各个通道的频率，前提是在Configuration中勾选到System Requirements。</p>
<p>本设计所用到的IP核Summary如下：</p>
<figure data-type="image" tabindex="4"><img src="https://imgs.raincorn.top/imgs/202110081602864.png" alt="image-20211008083826319" loading="lazy"></figure>
<h3 id="multiplier">Multiplier</h3>
<p>该IP核用于将两个输出相乘，最后输出的位宽等于两个输入位宽之和，即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo>=</mo><mi>A</mi><mo>∗</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">P=A*B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>。在使用该IP核时，一定要注意输入位宽与是否为有符号数匹配。有符号与无符号数在该IP核内的处理方式不同，可能会造成乘法错误。</p>
<h3 id="fir-compiler">FIR Compiler</h3>
<p>该IP核用于将输入信号进行FIR滤波，系数可从MATLAB的FDATOOL中导入，注意导入的数据需要在FDATOOL中量化为定点。</p>
<h4 id="filter-options">Filter Options</h4>
<ul>
<li>Filter Coefficients：此处可以手动输入抽头系数，或者由MATLAB导出。</li>
<li>Filter Specification：配置多速率FIR滤波器，出于性能问题在实际设计中常常使用CIC滤波器做多速率转换。</li>
</ul>
<h4 id="channel-specification">Channel Specification</h4>
<p>本页面需要关注Hardware Oversampling Specification，该选项可以指定时钟频率与采样率的关系。</p>
<h4 id="implementation-2">Implementation</h4>
<ul>
<li>Coefficient Type：输入抽头系数的数据类型，从MATLAB导入后保持默认即可。Coefficient Structure，此项用来指定抽头系数的类型：由系统推断，非对称与对称。</li>
<li>Data Path Options：设置输入输出数据的位宽，输出数据有一个Rounding Mode需要注意。Truncate LSBs可用于直接将低位舍去，保留高位，但我更倾向于仿真后手动截位。</li>
</ul>
<figure data-type="image" tabindex="5"><img src="https://imgs.raincorn.top/imgs/202110081602034.png" alt="image-20211008103433205" loading="lazy"></figure>
<p>本设计所用到的IP核Summary如下：</p>
<figure data-type="image" tabindex="6"><img src="https://imgs.raincorn.top/imgs/202110081602998.png" alt="image-20211008103639198" loading="lazy"></figure>
<h2 id="调制源文件">调制源文件</h2>
<pre><code class="language-c">`timescale 1ns / 1ps

module am_mod(
    input sys_clk,
    input sys_rst_n,
    input [7:0] adc_data_unsigned,
    output adc_clk,
    output [15:0] am_mod
    );

wire clk_10m,locked,valid;
assign valid = sys_rst_n &amp; locked;
assign adc_clk = valid ? clk_10m : 1'b0; //clk_10m时钟有效时输出到adc_clk，以10M的ADC时钟采样到adc_data_unsigned
ip_pll inst0(
    // Clock out ports
    .clk_10m(clk_10m),     // output clk_10m
    // Status and control signals
    .resetn(sys_rst_n), // input resetn
    .locked(locked),       // output locked
   // Clock in ports
    .clk_in(sys_clk)
);      // input clk_in

wire signed [7:0] carry_data;
wire carry_valid;
ip_dds inst1 (
  .aclk(sys_clk),                              // input wire aclk
  .aresetn(sys_rst_n),                        // input wire aresetn
  .m_axis_data_tvalid(carry_valid),  // output wire m_axis_data_tvalid
  .m_axis_data_tdata(carry_data)    // output wire [7 : 0] m_axis_data_tdata
);

parameter depth_inv = 2; //用来配置调制深度
wire signed [15:0] mult_data;
wire signed [7:0] adc_data;
assign adc_data = ((adc_data_unsigned - 8'd128) + depth_inv * 8'd128)/(depth_inv + 1);
assign am_mod = mult_data;
ip_mult inst2 (
  .CLK(sys_clk),  // input wire CLK
  .A(adc_data),      // input wire [7 : 0] A
  .B(carry_data),      // input wire [7 : 0] B
  .CE(valid),   // input wire CE
  .P(mult_data)      // output wire [15 : 0] P
);
    
endmodule
</code></pre>
<h2 id="调制testbench">调制TestBench</h2>
<p>注意此处的文件读写操作，用来输入基带信号，输出调制信号，输出到TXT的数据可在MATLAB中进一步的验证正确性。此外，fdisplay这个函数会根据wire或者reg在程序中定义的类型进行输出，此处定义为signed，默认为unsigned。注意将所需要的调试文件设为顶层设计。</p>
<pre><code class="language-c">`timescale 1ns / 1ps

module am_mod_tb(
    );

reg sys_clk;
reg sys_rst_n;  
reg [7:0] adc_data_unsigned;
wire adc_clk;
wire signed [15:0] am_mod;  
am_mod inst0(
    .sys_clk (sys_clk),
    .sys_rst_n (sys_rst_n),
    .adc_data_unsigned (adc_data_unsigned),
    .adc_clk (adc_clk),
    .am_mod (am_mod)
);
parameter clk_period = 20;
parameter data_num = 1000;

initial begin
    $readmemb(&quot;am_mod.txt&quot;,stimulus);
    sys_clk = 1'b0;
    sys_rst_n = 1'b0;
    adc_data_unsigned = 8'd0;
    #100 sys_rst_n = 1'b1;   
end

always #10 sys_clk = ~sys_clk;

integer pattern;
reg [7:0] stimulus [1:data_num];
always@(posedge adc_clk or negedge sys_rst_n) begin
    if(!sys_rst_n) begin
        adc_data_unsigned &lt;= 8'd0;
        pattern = 1; 
    end else if (pattern == data_num)begin
        adc_data_unsigned &lt;= stimulus[pattern];
        pattern = 1;
    end else begin
        adc_data_unsigned &lt;= stimulus[pattern];
        pattern = pattern + 1;
    end
end

integer file_out;
initial begin
    file_out = $fopen(&quot;am_mod_data.txt&quot;);
    if(!file_out) begin
        $display(&quot;Cloud open file!&quot;);
        $finish;
    end
end
wire write_clk;
assign write_clk = adc_clk &amp; sys_rst_n;
always@(posedge write_clk) begin
    $fdisplay(file_out,&quot;%d&quot;,am_mod);
end
    
endmodule

</code></pre>
<h2 id="调制结果">调制结果</h2>
<p>该图为仿真结果，可以看到am_mod信号的波形幅度与输入信号幅度同步变化，其包络大致与基带信号相同。此外16位am_mod的14位和15位同步变化，在后文将am_mod截断为8位无符号时将会利用此波形进行变换。</p>
<figure data-type="image" tabindex="7"><img src="https://imgs.raincorn.top/imgs/202110081602581.png" alt="image-20211008105707918" loading="lazy"></figure>
<p>将调试后输出的数据导入到MATLAB中分析频谱既可以观察到在归一化频率的0.19、0.2、0.21附近有尖峰，满足设计预期。</p>
<figure data-type="image" tabindex="8"><img src="https://imgs.raincorn.top/imgs/202110081602436.png" alt="image-20211008110042168" loading="lazy"></figure>
<h2 id="调制截位">调制截位</h2>
<p>由于我们使用的AD/DA模块是黑金的AN108，其输入输出均为8bit无符号数据，因此需要进行转换。注意此处因为第15位与14位相同，故此处直接将第15位作为符号位，以提高截位后的精度。</p>
<pre><code class="language-c">assign am_mod = {mult_data[15],mult_data[13:7]} + 8'd128;
</code></pre>
<h2 id="解调源文件">解调源文件</h2>
<p>AM信号的调制可以直接采用包络检波，在大信噪比的时候其性能与相干解调差距不大。使用Verilog来进行包络检波总体分为：整流&amp;滤波。其中整流即是对原始信号取绝对值操作，本工程中通过判断am_mod最高位来实现。滤波即使用FIR IP核来进行，通过在FDATOOL中设计一个通带归一化频率为0.02的滤波器，将系数导入到Vivado即可。注意在仿真数据出来以后可以将其放入信号分析器观察频谱，调整通阻带增益来达到更好的解调效果。</p>
<pre><code class="language-c">`timescale 1ns / 1ps

module am_demod(
    input sys_clk,
    input sys_rst_n,
    input [7:0] am_mod_unsigned,
    output adc_clk,
    output [7:0] m
    );

wire clk_10m,locked,valid;
assign valid = sys_rst_n &amp; locked;
assign adc_clk = valid ? clk_10m : 1'b0; //clk_10m时钟有效时输出到adc_clk，以10M的ADC时钟采样到adc_data_unsigned
ip_pll inst0(
    // Clock out ports
    .clk_10m(clk_10m),     // output clk_10m
    // Status and control signals
    .resetn(sys_rst_n), // input resetn
    .locked(locked),       // output locked
   // Clock in ports
    .clk_in(sys_clk)
);      // input clk_in    

wire signed [7:0] am_mod;
reg signed [7:0] am_abs;
assign am_mod = am_mod_unsigned - 8'd128;
always@(posedge sys_clk or negedge sys_rst_n) begin
    if(!sys_rst_n) begin
        am_abs &lt;= 8'd0;
    end else if(am_mod[7]) begin
        am_abs &lt;= -am_mod;
    end else begin
        am_abs &lt;= am_mod;
    end
end

wire inst1_s_axis_data_tready,inst1_m_axis_data_tvalid;
wire [31:0] inst1_m;
assign m = inst1_m[26:19] + 8'd128;
ip_fir inst1 (
  .aclk(clk_10m),                              // input wire aclk
  .s_axis_data_tvalid(valid),  // input wire s_axis_data_tvalid
  .s_axis_data_tready(inst1_s_axis_data_tready),  // output wire s_axis_data_tready
  .s_axis_data_tdata(am_abs),    // input wire [7 : 0] s_axis_data_tdata
  .m_axis_data_tvalid(inst1_m_axis_data_tvalid),  // output wire m_axis_data_tvalid
  .m_axis_data_tdata(inst1_m)    // output wire [31 : 0] m_axis_data_tdata
);
    
endmodule
</code></pre>
<h2 id="解调testbench">解调TestBench</h2>
<pre><code class="language-c">`timescale 1ns / 1ps

module am_demod_tb(
    );
reg sys_clk,sys_rst_n;
reg [7:0] adc_data_unsigned;
wire adc_clk,inst1_adc_clk;
wire [7:0] am_mod;    
wire [7:0] m;
am_mod inst0(
    .sys_clk (sys_clk),
    .sys_rst_n (sys_rst_n),
    .adc_data_unsigned (adc_data_unsigned),
    .adc_clk (adc_clk),
    .am_mod (am_mod)
);    

am_demod inst1(
    .sys_clk (sys_clk),
    .sys_rst_n (sys_rst_n),
    .am_mod_unsigned (am_mod),
    .adc_clk (inst1_adc_clk),
    .m (m)
);

parameter clk_period = 20;
parameter data_num = 1000;

initial begin
    $readmemb(&quot;am_mod.txt&quot;,stimulus);
    sys_clk = 1'b0;
    sys_rst_n = 1'b0;
    adc_data_unsigned = 8'd0;
    #100 sys_rst_n = 1'b1;   
end

always #10 sys_clk = ~sys_clk;

integer pattern;
reg [7:0] stimulus [1:data_num];
always@(posedge adc_clk or negedge sys_rst_n) begin
    if(!sys_rst_n) begin
        adc_data_unsigned &lt;= 8'd0;
        pattern = 1; 
    end else if (pattern == data_num)begin
        adc_data_unsigned &lt;= stimulus[pattern];
        pattern = 1;
    end else begin
        adc_data_unsigned &lt;= stimulus[pattern];
        pattern = pattern + 1;
    end
end

integer file_out;
initial begin
    file_out = $fopen(&quot;am_demod_data.txt&quot;);
    if(!file_out) begin
        $display(&quot;Cloud open file!&quot;);
        $finish;
    end
end
wire write_clk;
assign write_clk = adc_clk &amp; sys_rst_n;
always@(posedge write_clk) begin
    $fdisplay(file_out,&quot;%d&quot;,m);
end
    
endmodule
</code></pre>
<h2 id="解调结果">解调结果</h2>
<p>FPGA仿真后的波形如下图所示，FIR滤波器存在相位延迟，故在一段时间内输出的波形不正确。</p>
<figure data-type="image" tabindex="9"><img src="https://imgs.raincorn.top/imgs/202110081601649.png" alt="image-20211008104710570" loading="lazy"></figure>
<p>将输出的波形导入到信号分析器，既可以观察到在0（直流分量）与0.02（100KHz的基带信号）附近有频点。如果希望波形还原更加完善，可以在FDATOOL中提高阻带权重，以滤除0.4（二次谐波）与0.8附近的频率。</p>
<figure data-type="image" tabindex="10"><img src="https://imgs.raincorn.top/imgs/202110081601907.png" alt="image-20211008105049483" loading="lazy"></figure>
<h1 id="其他">其他</h1>
<ul>
<li>AM调制的调制效率最大为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>1</mn><mn>3</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，信号利用率较低，频带利用率也较低。但是由于其可通过包络检波直接提取原始信号，故其成本极低，现在仍被用于无线电广播。</li>
<li>在FPGA仿真后，需要对仿真数据进行分析。此时建议使用MATLAB的“信号分析器”来对频谱进行分析，此APP的功能强大且易用。可用于查看信号频谱，滤波器初步设计，包络提取等功能，推荐。</li>
<li>FPGA的操作中受限于资源所限，常常会对数据进行截位，此时可以根据信号的仿真波形以及IP核的Implementation上的接口说明来撰写截位代码。</li>
</ul>
<h1 id="参考文献">参考文献</h1>
<blockquote>
<p>《通信原理（第七版）》樊昌信 曹丽娜著</p>
</blockquote>
<blockquote>
<p>《数字调制解调技术的MATLAB与FPGA实现》 杜勇著</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于]]></title>
        <id>https://raincorn.top/about/</id>
        <link href="https://raincorn.top/about/">
        </link>
        <updated>2022-01-20T12:19:56.000Z</updated>
        <content type="html"><![CDATA[<p>由于之前站点的备份丢失，Markdown源文件已无法恢复。原站点已作归档处理，归档在<a href="https://old.raincorn.top">old.raincorn.top</a>。</p>
<h1 id="博主是谁">博主是谁</h1>
<p>一名普通到不能再普通的在校学生，目前大三。</p>
<h1 id="擅长什么">擅长什么</h1>
<p>软硬件都略有涉猎，目前的精力主要集中在FPGA/ASIC开发上，当然通信是老本行。</p>
<h1 id="联系方式">联系方式</h1>
<p>我的邮箱为：rain_corn@foxmail.com 。</p>
]]></content>
    </entry>
</feed>